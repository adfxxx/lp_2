#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Доянова В.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Можно выделить два основных подхода к решению логических задач:
* Метод порождения и проверок. Заключается в переборе всех возможных вариантов решения и проверке их на соответствие условиям. Prolog в данном случае позволяет легко описать все возможные варианты в виде правил и фактов для их рассмотрения.
* Метод ветвей и границ. Данный метод заключается в разбиении задачи на подзадачи. На каждом этапа происходит проверка, есть ли смысл продолжать работу с конкретной ветвью поиска. Prolog позволяет осуществлять такое решение с помощью рекурсивных правил.

Таким образом, благодаря возможности явно описывать условия, ограничения, заданные в условии, а также использовать рекурсивные функции Prolog является удобным языком для написания решателей логических задач.

## Задание

11. 6 человек назовем их А, Б, В, Г, Д и Е кандидаты посты председателя, заместителя председателя и секретаря правления общества любителей логических задач. Но определить состав этой тройки оказалось не так-то легко. Судите сами: А не хочет входить в состав руководства, если Д не будет председателем. Б не хочет входить в состав руководства, если ему придется быть старшим над В. Б не хочет работать вместе с Е ни при каких условиях. В не хочет работать, если в состав руководства войдут Д и Е вместе. В не будет работать, если Е будет председателем, или если Б будет секретарем. Г не будет работать с В или Д, если ему придется подчиняться тому или другому. Д не хочет быть заместителем председателя. Д не хочет быть секретарем, если в состав руководства войдет Г. Д не хочет работать вместе с А, если Е не войдет в состав руководства. Е согласен работать только в том случае, если председателем будет либо он, либо В. Как они решили эту проблему?

## Принцип решения

Заведем список должностей: "Chairman" (председатель), "Vice" (заместитель), "Secretary" (секретарь), "Citizen" (человек без должности). Будем проверять каждое условие для нахождения единственного решения.

Предикат all_situations проверяет каждую перестановку (получается с помощью предиката permutation) на соответствие условиям:
```prolog
all_situations([A,B,V,G,D,E]) :- 
  Positions = ["Chairman", "Vice", "Secretary", "Citizen", "Citizen", "Citizen"],
  permutation([A,B,V,G,D,E], Positions),
  situation_1(A,B,V,G,D,E),
  situation_2(A,B,V,G,D,E),
  situation_3(A,B,V,G,D,E),
  situation_4(A,B,V,G,D,E),
  situation_5(A,B,V,G,D,E),
  situation_6(A,B,V,G,D,E),
  situation_7(A,B,V,G,D,E),
  situation_8(A,B,V,G,D,E),
  situation_9(A,B,V,G,D,E),
  situation_10(A,B,V,G,D,E).
```
Предикаты situation_1,...,situation_10 проверяют каждое условие, описанное в задаче, и в случае несоответствия ему возвращает fail.

Предикат solve с помощью предиката setof получает уникальные решения, которые затем выводятся в качестве ответа на задачу:
```prolog
solve() :- 
	setof([A,B,V,G,D,E], all_situations([A,B,V,G,D,E]), [[T,U,W,X,Y,Z]]),
	write("A: "), write(T), nl,
	write("B: "), write(U), nl,
	write("V: "), write(W), nl,
	write("G: "), write(X), nl,
	write("D: "), write(Y), nl,
	write("E: "), write(Z), nl.
```
Полученный ответ:
```prolog
A: Citizen
B: Vice
V: Chairman
G: Citizen
D: Secretary
E: Citizen
true
```
## Выводы

Данная лабораторная работа позволила мне изучить основные методы решения логических задач на Прологе, а также дала возможность самостоятельно попробовать решить задачу с использованием средств изучаемого языка. 

Анализируя написанную мной программу, можно сделать выводы о её безопасности, эффективности и непротиворечивости решения. Так, в ходе работы происходит перебор всех возможных вариантов, что не кажется достаточно эффективным вариантом, но при этом происходит отсечение неподходящих вариантов с помощью возвращения fail. Поэтому можно сказать, что программа достаточно эффективна, её сложность равняется O(n!). Также отсечения делают программу безопасной, так как исключается возможность попадания в бесконечный цикл. Кроме этого, программа выводит один ответ на задачу, что говорит о непротиворечивости решения.




